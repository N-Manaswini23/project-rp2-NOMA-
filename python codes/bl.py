# -*- coding: utf-8 -*-
"""BL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ul2gJ1bcQyeyWEQQMFe3W_0RzLn7Vz2G
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import math
import mpmath
from scipy import stats
import scipy.integrate as integrate
from scipy import stats
import scipy.special as special
import itertools










#*******************************************************************************
#*******************************************************************************
#The below code for multivariate fox h function is from
# https://github.com/melayadi/multivarFoxH

from __future__ import division
import numpy as np
import scipy.special as special
import itertools
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import math
from scipy import integrate
import mpmath

def detBoundaries(params, tol):
    '''This modules attempts to determine an appropriate  rectangular 
    boundaries of the integration region of the multivariate Fox H function.'''
    boundary_range = np.arange(0, 50, 0.05)
    dims = len(params[0])
    boundaries = np.zeros(dims)
    for dim_l in range(dims):
        points = np.zeros((boundary_range.shape[0], dims))
        points[:, dim_l] = boundary_range
        abs_integrand = np.abs(compMultiFoxHIntegrand(points, params))
        index = np.max(np.nonzero(abs_integrand>tol*abs_integrand[0]))
        boundaries[dim_l] = boundary_range[index]
    return boundaries

def compMultiFoxHIntegrand(y, params):
    ''' This module computes the complex integrand of the multivariate Fox-H
    function at the points given by the rows of the matrix y.'''
    z, mn, pq, c, d, a, b = params
    m, n = zip(*mn)
    p, q = zip(*pq)
    npoints, dims = y.shape
    s = 1j*y
    
    # Estimating sigma[l]
    lower = np.zeros(dims)
    upper = np.zeros(dims)
    for dim_l in range(dims):
        if b[dim_l]:
            bj, Bj = zip(*b[dim_l])
            bj = np.array(bj[:m[dim_l+1]])
            Bj = np.array(Bj[:m[dim_l+1]])
            lower[dim_l] = -np.min(bj/Bj)
        else:
            lower[dim_l] = -100
        if a[dim_l]:
            aj, Aj = zip(*a[dim_l])
            aj = np.array(aj[:n[dim_l+1]])
            Aj = np.array(Aj[:n[dim_l+1]])
            upper[dim_l] =  np.min((1-aj)/Aj)
        else:
            upper[dim_l] = 0    
    mindist = np.linalg.norm(upper-lower)
    sigs = 0.5*(upper+lower)
    for j in range(n[0]):
        num = 1 - c[j][0] - np.sum(c[j][1:] * lower)
        cnorm = np.linalg.norm(c[j][1:])
        newdist = np.abs(num) / cnorm
        if newdist < mindist:
            mindist = newdist
            sigs = lower + 0.5*num*np.array(c[j][1:])/(cnorm*cnorm)    
    s += sigs
    
    # Computing products of Gamma factors on both numeratos and denomerator
    s1 = np.c_[np.ones((npoints, 1)), s]    
    prod_gam_num = prod_gam_denom = 1+0j
    for j in range(n[0]):
        prod_gam_num *= special.gamma(1-np.dot(s1, c[j]))
    for j in range(q[0]):
        prod_gam_denom *= special.gamma(1-np.dot(s1, d[j]))
    for j in range(n[0], p[0]):
        prod_gam_denom *= special.gamma(np.dot(s1,c[j]))    
    for dim_l in range(dims):
        for j in range(n[dim_l+1]):
            prod_gam_num *= special.gamma(1 - a[dim_l][j][0] - a[dim_l][j][1]*s[:, dim_l])
        for j in range(m[dim_l+1]):
            prod_gam_num *= special.gamma(b[dim_l][j][0] + b[dim_l][j][1]*s[:, dim_l])
        for j in range(n[dim_l+1], p[dim_l+1]):
            prod_gam_denom *= special.gamma(a[dim_l][j][0] + a[dim_l][j][1]*s[:, dim_l])
        for j in range(m[dim_l+1], q[dim_l+1]):
            prod_gam_denom *= special.gamma(1 - b[dim_l][j][0] - b[dim_l][j][1]*s[:, dim_l])

    # Final integrand    
    zs = np.power(z, -s)
    result = (prod_gam_num/prod_gam_denom)*np.prod(zs, axis=1)/(2*np.pi)**dims
    #the complex j is not forgotten
    return result

def compMultiFoxH(params, nsubdivisions, boundaryTol=0.0001):
    '''This module estimates a multivariate integral using simple rectangule 
    quadrature. In most practical applications, 20 points per dimension provided
    sufficient accuracy.
    Inputs:
    'params': list containing z, mn, pq, c, d, a, b.
    'nsubdivisions': the number of divisions taken along each dimension. Note
    that the total number of points will be nsubdivisions**dim.
    'boundaryTol': tolerance used for determining the boundaries
    Output:
    'result': the estimated value of the multivariate Fox H function...'''
    boundaries = detBoundaries(params, boundaryTol)
    dim = boundaries.shape[0]
    signs = list(itertools.product([1,-1], repeat=dim))
    code = list(itertools.product(range(int(nsubdivisions/2)), repeat=dim))
    quad = 0
    res = np.zeros((0))
    for sign in signs:
        points = np.array(sign)*(np.array(code)+0.5)*boundaries*2/nsubdivisions
        res = np.r_[res,np.real(compMultiFoxHIntegrand(points, params))]
        quad += np.sum(compMultiFoxHIntegrand(points, params))
    volume = np.prod(2*boundaries/nsubdivisions)
    result = quad*volume
    return result



#The above code for multivariate fox h function is from
# https://github.com/melayadi/multivarFoxH

#*******************************************************************************
#*******************************************************************************




















def p(x,y):
 if (x==1):
   p=y*((math.sqrt(0.3)+math.sqrt(0.7))**2)/4
 if (x==2):
   p=y*((-math.sqrt(0.3)+math.sqrt(0.7))**2)/4
 if (x==3):
   p=y*(math.sqrt(0.7)**2)      
 if (x==4):
   p=y*((math.sqrt(0.3)+math.sqrt(0.7))**2)
 if (x==5):
   p=y*((math.sqrt(0.3)-math.sqrt(0.7))**2)/2
 if (x==6):
   p=y*(math.sqrt(0.3)**2)/2
 if (x==7):
   p=2*y*(math.sqrt(0.3)**2)      
 if (x==8):
   p=y*((-math.sqrt(0.3)+math.sqrt(0.7))**2)/2
 if (x==9):
   p=y*((-math.sqrt(0.3)+2*math.sqrt(0.7))**2)/2
 if (x==10):
   p=y*((math.sqrt(0.3)+2*math.sqrt(0.7))**2)/2
 if (x==11):
   p=y*((-math.sqrt(0.3)+math.sqrt(0.7))**2)
 if (x==12):
   p=y*((math.sqrt(0.3)+math.sqrt(0.7))**2)/2
 return p

def mu(p_func,w,a,b,c,lam):
  return p_func/(2*w*(lam**2)+((b**2)*(1-w)*special.gamma(a+(2/c))/special.gamma(a)))

def H11(mu_func):
  lamb= 0.4771
  z1=2 / ((lamb**2)*mu_func)
  params=[[z1],[[0,0],[1,2]],[[0,0],[2,2]],[],[],[[[1,1],[0.5,1]]],[[[1,2],[0,1]]]]
  h1=compMultiFoxH(params,7)
  return h1



def H12(mu_func):
  a=0.4319
  b= 1.4531
  c=  74.3650
  z2=2/((b**2)*mu_func)
  params=[[z2],[[0,0],[1,2]],[[0,0],[2,2]],[],[],[[[1,1],[0.5,1]]],[[[a,2/c],[0,1]]]]
  h2=compMultiFoxH(params,7)
  return h2



def H21(mu_func):
  lamb= 0.4603
  z1=2 / ((lamb**2)*mu_func)
  params=[[z1],[[0,0],[1,2]],[[0,0],[2,2]],[],[],[[[1,1],[0.5,1]]],[[[1,2],[0,1]]]]
  h1=compMultiFoxH(params,7)
  return h1



def H22(mu_func):
  a=1.2526
  b= 1.1501
  c= 41.3258
  z2=2/((b**2)*mu_func)
  params=[[z2],[[0,0],[1,2]],[[0,0],[2,2]],[],[],[[[1,1],[0.5,1]]],[[[a,2/c],[0,1]]]]
  h2=compMultiFoxH(params,7)
  return h2


def X(H1_func,H2_func,w,a):
  X=((H1_func)*w/(2*math.sqrt(np.pi)))+((H2_func)*(1-w)/(2*math.sqrt(np.pi)*special.gamma(a)))
  return X




























Puv1=np.array([])
Puv2=np.array([])

w=0.3489
lam= 0.4771
a=0.4319
b= 1.4531
c=  74.3650



y=np.arange(26.5,48,0.5)






#num=100
for k,j in enumerate(y):
   i= 10**(j/10)


   h11=0
   h21=0
   h11=H11(mu(p(1,i),w,a,b,c,lam))
   h21=H12(mu(p(1,i),w,a,b,c,lam))
   X1=(np.real(X(h11,h21,w,a)))
  


   h12=0
   h22=0
   h12=H11(mu(p(2,i),w,a,b,c,lam))
   h22=H12(mu(p(2,i),w,a,b,c,lam))
   X2=(np.real(X(h12,h22,w,a)))
  

   h13=0
   h23=0
   h13=H11(mu(p(3,i),w,a,b,c,lam))
   h23=H12(mu(p(3,i),w,a,b,c,lam))
   X3=(np.real(X(h13,h23,w,a)))
  


   h14=0
   h24=0
   h14=H11(mu(p(4,i),w,a,b,c,lam))
   h24=H12(mu(p(4,i),w,a,b,c,lam))
   X4=(np.real(X(h14,h24,w,a)))



   puv2=abs((2*X1+2*X2-X3-X4)/4)
   Puv2=np.append(Puv2,puv2)
   





   h15=0
   h25=0
   h15=H11(mu(p(5,i),w,a,b,c,lam))
   h25=H12(mu(p(5,i),w,a,b,c,lam))
   X5=(np.real(X(h15,h25,w,a)))


   h16=0
   h26=0
   h16=H11(mu(p(6,i),w,a,b,c,lam))
   h26=H12(mu(p(6,i),w,a,b,c,lam))
   X6=(np.real(X(h16,h26,w,a)))


   h17=0
   h27=0
   h17=H11(mu(p(7,i),w,a,b,c,lam))
   h27=H12(mu(p(7,i),w,a,b,c,lam))
   X7=(np.real(X(h17,h27,w,a)))


   h18=0
   h28=0
   h18=H11(mu(p(8,i),w,a,b,c,lam))
   h28=H12(mu(p(8,i),w,a,b,c,lam))
   X8=(np.real(X(h18,h28,w,a)))


   h19=0
   h29=0
   h19=H11(mu(p(9,i),w,a,b,c,lam))
   h29=H12(mu(p(9,i),w,a,b,c,lam))
   X9=(np.real(X(h19,h29,w,a)))


   h110=0
   h210=0
   h110=H11(mu(p(10,i),w,a,b,c,lam))
   h210=H12(mu(p(10,i),w,a,b,c,lam))
   X10=(np.real(X(h110,h210,w,a)))


   h111=0
   h211=0
   h111=H11(mu(p(11,i),w,a,b,c,lam))
   h211=H12(mu(p(11,i),w,a,b,c,lam))
   X11=(np.real(X(h111,h211,w,a)))


   h112=0
   h212=0
   h112=H11(mu(p(12,i),w,a,b,c,lam))
   h212=H12(mu(p(12,i),w,a,b,c,lam))
   X12=(np.real(X(h112,h212,w,a)))


   puv1=abs((X5+3*X6-X7+2*X8-2*X9+X10-X11-X12)/4)
   Puv1=np.append(Puv1,puv1)
   

   













Puv12=np.array([])
Puv22=np.array([])





w=0.2109
lam=  0.4603
a=1.2526
b= 1.1501
c= 41.3258

for k,j in enumerate(y):
   i= 10**(j/10)


   h11=0
   h21=0
   h11=H21(mu(p(1,i),w,a,b,c,lam))
   h21=H22(mu(p(1,i),w,a,b,c,lam))
   X1=(np.real(X(h11,h21,w,a)))



   h12=0
   h22=0
   h12=H21(mu(p(2,i),w,a,b,c,lam))
   h22=H22(mu(p(2,i),w,a,b,c,lam))
   X2=(np.real(X(h12,h22,w,a)))

   h13=0
   h23=0
   h13=H21(mu(p(3,i),w,a,b,c,lam))
   h23=H22(mu(p(3,i),w,a,b,c,lam))
   X3=(np.real(X(h13,h23,w,a)))


   h14=0
   h24=0
   h14=H21(mu(p(4,i),w,a,b,c,lam))
   h24=H22(mu(p(4,i),w,a,b,c,lam))
   X4=(np.real(X(h14,h24,w,a)))


   puv2=abs((2*X1+2*X2-X3-X4)/4)
   Puv22=np.append(Puv22,puv2)
 





   h15=0
   h25=0
   h15=H21(mu(p(5,i),w,a,b,c,lam))
   h25=H22(mu(p(5,i),w,a,b,c,lam))
   X5=(np.real(X(h15,h25,w,a)))


   h16=0
   h26=0
   h16=H21(mu(p(6,i),w,a,b,c,lam))
   h26=H22(mu(p(6,i),w,a,b,c,lam))
   X6=(np.real(X(h16,h26,w,a)))


   h17=0
   h27=0
   h17=H21(mu(p(7,i),w,a,b,c,lam))
   h27=H22(mu(p(7,i),w,a,b,c,lam))
   X7=(np.real(X(h17,h27,w,a)))


   h18=0
   h28=0
   h18=H21(mu(p(8,i),w,a,b,c,lam))
   h28=H22(mu(p(8,i),w,a,b,c,lam))
   X8=(np.real(X(h18,h28,w,a)))


   h19=0
   h29=0
   h19=H21(mu(p(9,i),w,a,b,c,lam))
   h29=H22(mu(p(9,i),w,a,b,c,lam))
   X9=(np.real(X(h19,h29,w,a)))


   h110=0
   h210=0
   h110=H21(mu(p(10,i),w,a,b,c,lam))
   h210=H22(mu(p(10,i),w,a,b,c,lam))
   X10=(np.real(X(h110,h210,w,a)))


   h111=0
   h211=0
   h111=H21(mu(p(11,i),w,a,b,c,lam))
   h211=H22(mu(p(11,i),w,a,b,c,lam))
   X11=(np.real(X(h111,h211,w,a)))


   h112=0
   h212=0
   h112=H21(mu(p(12,i),w,a,b,c,lam))
   h212=H22(mu(p(12,i),w,a,b,c,lam))
   X12=(np.real(X(h112,h212,w,a)))

   puv1=abs((X5+3*X6-X7+2*X8-2*X9+X10-X11-X12)/4)
   Puv12=np.append(Puv12,puv1)




plt.semilogy(y,Puv1,color='r',marker='o',linestyle='-',label='Puv1 BL=7.1L/min')
plt.semilogy(y,Puv2,color='b',marker='o',linestyle='-',label='Puv2 BL=7.1L/min')
plt.semilogy(y,Puv12,color='g',marker='o',linestyle='-',label='Puv1 BL=4.7L/min')
plt.semilogy(y,Puv22,color='purple',marker='o',linestyle='-',label='Puv2 BL=4.7L/min')
plt.xlabel("snr (in db)");
plt.ylabel("avg BER")
plt.grid()
plt.title("avg ber at different BL")
plt.legend()
plt.show()