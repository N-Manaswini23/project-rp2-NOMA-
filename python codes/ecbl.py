# -*- coding: utf-8 -*-
"""ECBL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13qwmh1lBz4Zond7cxK4AT-YfTBx0gynR
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import math
import mpmath
from scipy import stats
import scipy.integrate as integrate
from scipy import stats
import scipy.special as special
import itertools










#*******************************************************************************
#*******************************************************************************
#The below code for multivariate fox h function is from
# https://github.com/melayadi/multivarFoxH

from __future__ import division
import numpy as np
import scipy.special as special
import itertools
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import math
from scipy import integrate
import mpmath

def detBoundaries(params, tol):
    '''This modules attempts to determine an appropriate  rectangular 
    boundaries of the integration region of the multivariate Fox H function.'''
    boundary_range = np.arange(0, 50, 0.05)
    dims = len(params[0])
    boundaries = np.zeros(dims)
    for dim_l in range(dims):
        points = np.zeros((boundary_range.shape[0], dims))
        points[:, dim_l] = boundary_range
        abs_integrand = np.abs(compMultiFoxHIntegrand(points, params))
        index = np.max(np.nonzero(abs_integrand>tol*abs_integrand[0]))
        boundaries[dim_l] = boundary_range[index]
    return boundaries

def compMultiFoxHIntegrand(y, params):
    ''' This module computes the complex integrand of the multivariate Fox-H
    function at the points given by the rows of the matrix y.'''
    z, mn, pq, c, d, a, b = params
    m, n = zip(*mn)
    p, q = zip(*pq)
    npoints, dims = y.shape
    s = 1j*y
    
    # Estimating sigma[l]
    lower = np.zeros(dims)
    upper = np.zeros(dims)
    for dim_l in range(dims):
        if b[dim_l]:
            bj, Bj = zip(*b[dim_l])
            bj = np.array(bj[:m[dim_l+1]])
            Bj = np.array(Bj[:m[dim_l+1]])
            lower[dim_l] = -np.min(bj/Bj)
        else:
            lower[dim_l] = -100
        if a[dim_l]:
            aj, Aj = zip(*a[dim_l])
            aj = np.array(aj[:n[dim_l+1]])
            Aj = np.array(Aj[:n[dim_l+1]])
            upper[dim_l] =  np.min((1-aj)/Aj)
        else:
            upper[dim_l] = 0    
    mindist = np.linalg.norm(upper-lower)
    sigs = 0.5*(upper+lower)
    for j in range(n[0]):
        num = 1 - c[j][0] - np.sum(c[j][1:] * lower)
        cnorm = np.linalg.norm(c[j][1:])
        newdist = np.abs(num) / cnorm
        if newdist < mindist:
            mindist = newdist
            sigs = lower + 0.5*num*np.array(c[j][1:])/(cnorm*cnorm)    
    s += sigs
    
    # Computing products of Gamma factors on both numeratos and denomerator
    s1 = np.c_[np.ones((npoints, 1)), s]    
    prod_gam_num = prod_gam_denom = 1+0j
    for j in range(n[0]):
        prod_gam_num *= special.gamma(1-np.dot(s1, c[j]))
    for j in range(q[0]):
        prod_gam_denom *= special.gamma(1-np.dot(s1, d[j]))
    for j in range(n[0], p[0]):
        prod_gam_denom *= special.gamma(np.dot(s1,c[j]))    
    for dim_l in range(dims):
        for j in range(n[dim_l+1]):
            prod_gam_num *= special.gamma(1 - a[dim_l][j][0] - a[dim_l][j][1]*s[:, dim_l])
        for j in range(m[dim_l+1]):
            prod_gam_num *= special.gamma(b[dim_l][j][0] + b[dim_l][j][1]*s[:, dim_l])
        for j in range(n[dim_l+1], p[dim_l+1]):
            prod_gam_denom *= special.gamma(a[dim_l][j][0] + a[dim_l][j][1]*s[:, dim_l])
        for j in range(m[dim_l+1], q[dim_l+1]):
            prod_gam_denom *= special.gamma(1 - b[dim_l][j][0] - b[dim_l][j][1]*s[:, dim_l])

    # Final integrand    
    zs = np.power(z, -s)
    result = (prod_gam_num/prod_gam_denom)*np.prod(zs, axis=1)/(2*np.pi)**dims
    #the complex j is not forgotten
    return result

def compMultiFoxH(params, nsubdivisions, boundaryTol=0.0001):
    '''This module estimates a multivariate integral using simple rectangule 
    quadrature. In most practical applications, 20 points per dimension provided
    sufficient accuracy.
    Inputs:
    'params': list containing z, mn, pq, c, d, a, b.
    'nsubdivisions': the number of divisions taken along each dimension. Note
    that the total number of points will be nsubdivisions**dim.
    'boundaryTol': tolerance used for determining the boundaries
    Output:
    'result': the estimated value of the multivariate Fox H function...'''
    boundaries = detBoundaries(params, boundaryTol)
    dim = boundaries.shape[0]
    signs = list(itertools.product([1,-1], repeat=dim))
    code = list(itertools.product(range(int(nsubdivisions/2)), repeat=dim))
    quad = 0
    res = np.zeros((0))
    for sign in signs:
        points = np.array(sign)*(np.array(code)+0.5)*boundaries*2/nsubdivisions
        res = np.r_[res,np.real(compMultiFoxHIntegrand(points, params))]
        quad += np.sum(compMultiFoxHIntegrand(points, params))
    volume = np.prod(2*boundaries/nsubdivisions)
    result = quad*volume
    return result



#The above code for multivariate fox h function is from
# https://github.com/melayadi/multivarFoxH

#*******************************************************************************
#*******************************************************************************

def p1(y):
  p=y*(0.25)
  return p


def p2(y):
  p=(y*0.75)/((y*(0.25))+2)
  return p


def mu(p_func,w,a,b,c,lam):
  return p_func/(2*w*(lam**2)+((b**2)*(1-w)*special.gamma(a+(2/c))/special.gamma(a)))


def H11(mu_func,lamb):
  z1=(2*np.pi)/ ((lamb**2)*mu_func*math.exp(1))
  params=[[z1],[[0,0],[3,1]],[[0,0],[2,3]],[],[],[[[0,1],[1,1]]],[[[1,2],[0,1],[0,1]]]]
  h1=compMultiFoxH(params,30)
  return h1



def H12(mu_func,a,b,c):
  z2=(2*np.pi)/ ((b**2)*mu_func*math.exp(1))
  params=[[z2],[[0,0],[3,1]],[[0,0],[2,3]],[],[],[[[0,1],[1,1]]],[[[a,2/c],[0,1],[0,1]]]]
  h2=compMultiFoxH(params,30)
  return h2


def Cuv(H1_func,H2_func,w,a):
  X=((H1_func)*w)+((H2_func)*(1-w)/special.gamma(a))
  return X






y=np.arange(0,20,0.5)




Cuv11=np.array([])
Cuv21=np.array([])
Cuv1=np.array([])
w=0.2130
lam=  0.3291
a=1.4299
b=1.1817
c= 17.1984 



for k,j in enumerate(y):
   i= 10**(j/10)
    
   h11=0
   h21=0
   h11=H11(mu(p1(i),w,a,b,c,lam),lam)
   h21=H12(mu(p1(i),w,a,b,c,lam),a,b,c)
   cuv1=(np.real(Cuv(h11,h21,w,a)))
   Cuv11=np.append(Cuv11,cuv1)


   h12=0
   h22=0
   h12=H11(mu(p2(i),w,a,b,c,lam),lam)
   h22=H12(mu(p2(i),w,a,b,c,lam),a,b,c)
   cuv2=(np.real(Cuv(h12,h22,w,a)))
   Cuv21=np.append(Cuv21,cuv2)
   cuv=cuv1+cuv2
   Cuv1=np.append(Cuv1,cuv)  


   
Cuv12=np.array([])
Cuv22=np.array([])
Cuv2=np.array([])
w=0.4539
lam=  0.2744
a=0.3008
b=1.7053
c= 54.1422



for k,j in enumerate(y):
   i= 10**(j/10)
    
   h11=0
   h21=0
   h11=H11(mu(p1(i),w,a,b,c,lam),lam)
   h21=H12(mu(p1(i),w,a,b,c,lam),a,b,c)
   cuv1=(np.real(Cuv(h11,h21,w,a)))
   Cuv12=np.append(Cuv12,cuv1)


   h12=0
   h22=0
   h12=H11(mu(p2(i),w,a,b,c,lam),lam)
   h22=H12(mu(p2(i),w,a,b,c,lam),a,b,c)
   cuv2=(np.real(Cuv(h12,h22,w,a)))
   Cuv22=np.append(Cuv22,cuv2)
   cuv=cuv1+cuv2
   Cuv2=np.append(Cuv2,cuv) 




plt.semilogy(y,Cuv11,color='red',marker='o',linestyle='-',label='Cuv1 BL=2.4L/min')
plt.semilogy(y,Cuv21,color='blue',marker='o',linestyle='-',label='Cuv2 BL=2.4L/min')
plt.semilogy(y,Cuv12,color='g',marker='o',linestyle='-',label='Cuv1 BL=4.7L/min')
plt.semilogy(y,Cuv22,color='purple',marker='o',linestyle='-',label='Cuv2 BL=4.7L/min')
plt.semilogy(y,Cuv1,color='black',marker='o',linestyle='-',label='Cuv(sum) BL=2.4L/min')
plt.semilogy(y,Cuv2,color='magenta',marker='o',linestyle='-',label='Cuv(sum) BL=4.7L/min')


plt.xlabel("snr (in db)");
plt.ylabel("avg ergodic capacity")
plt.grid()
plt.title("avg ergodic capacity at different BL")
plt.legend()
plt.show()